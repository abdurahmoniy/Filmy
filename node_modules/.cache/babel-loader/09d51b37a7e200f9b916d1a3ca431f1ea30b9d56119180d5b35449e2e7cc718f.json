{"ast":null,"code":"import { compute as e } from \"compute-scroll-into-view\";\nlet t = e => \"object\" == typeof e && \"function\" == typeof e.behavior,\n  o = e => !1 === e ? {\n    block: \"end\",\n    inline: \"nearest\"\n  } : (e => e === Object(e) && 0 !== Object.keys(e).length)(e) ? e : {\n    block: \"start\",\n    inline: \"nearest\"\n  };\nfunction n(n, l) {\n  if (!n.isConnected || !n.ownerDocument.documentElement.contains(n)) return;\n  if (t(l)) return l.behavior(e(n, l));\n  let i = \"boolean\" == typeof l || null == l ? void 0 : l.behavior;\n  for (let {\n    el: t,\n    top: r,\n    left: c\n  } of e(n, o(l))) t.scroll({\n    top: r,\n    left: c,\n    behavior: i\n  });\n}\nexport { n as default };","map":{"version":3,"names":["t","e","behavior","o","block","inline","Object","keys","length","n","l","isConnected","ownerDocument","documentElement","contains","i","el","top","r","left","c","scroll","default"],"sources":["/Users/student/Desktop/Filmy/node_modules/scroll-into-view-if-needed/src/index.ts"],"sourcesContent":["import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nlet isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nlet isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nlet getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (\n    !target.isConnected ||\n    !target.ownerDocument!.documentElement!.contains(target)\n  ) {\n    return\n  }\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  let behavior = typeof options === 'boolean' ? undefined : options?.behavior\n  for (let { el, top, left } of compute(target, getOptions(options))) {\n    el.scroll({ top, left, behavior })\n  }\n}\n\nexport default scrollIntoView\n"],"mappings":";AAgDA,IAKIA,CAAA,GACFC,CAAA,IAEmB,mBAAZA,CAAA,IAAmD,qBAArBA,CAAA,CAAQC,QAAA;EAE3CC,CAAA,GAAcF,CAAA,KAEA,MAAZA,CAAA,GACK;IAAEG,KAAA,EAAO;IAAOC,MAAA,EAAQ;EAAA,IAZjC,CAAAJ,CAAA,IAEAA,CAAA,KAAYK,MAAA,CAAOL,CAAA,KAA4C,MAAhCK,MAAA,CAAOC,IAAA,CAAKN,CAAA,EAASO,MAAA,EAavBP,CAAA,IAEpBA,CAAA,GAIF;IAAEG,KAAA,EAAO;IAASC,MAAA,EAAQ;EAAA;AAiCnC,SAASI,EACPA,CAAA,EACAC,CAAA;EAIE,KAACD,CAAA,CAAOE,WAAA,KACPF,CAAA,CAAOG,aAAA,CAAeC,eAAA,CAAiBC,QAAA,CAASL,CAAA,GAEjD;EAGE,IAAAT,CAAA,CAA0BU,CAAA,GAC5B,OAAOA,CAAA,CAAQR,QAAA,CAASD,CAAA,CAAQQ,CAAA,EAAQC,CAAA;EAG1C,IAAIK,CAAA,GAA8B,oBAAZL,CAAA,IAA6C,QAATA,CAAA,QAAZ,IAAqBA,CAAA,CAAAR,QAAA;EAC1D;IAAAc,EAAA,EAAEhB,CAAA;IAAIiB,GAAA,EAAAC,CAAA;IAAAC,IAAA,EAAKC;EAAA,KAAUnB,CAAA,CAAQQ,CAAA,EAAQN,CAAA,CAAWO,CAAA,IACvDV,CAAA,CAAGqB,MAAA,CAAO;IAAEJ,GAAA,EAAAC,CAAA;IAAKC,IAAA,EAAAC,CAAA;IAAMlB,QAAA,EAAAa;EAAA,EAE3B;AAAA;AAAA,SAAAN,CAAA,IAAAa,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}